#include <vm/vm.h>

#include <palacios/vmm.h>
#include <palacios/vmm_io.h>

#include <libs/stdarg.h>

static void
palacios_print(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vkprintf(fmt, ap);
	va_end(ap);
}

static void *
palacios_allocate_pages(int pages)
{
	return (void *)PADDR_DIRECT(kalloc_pages(pages));
}

static void
palacios_free_page(void *page_phys)
{
	/* XXX */
}

static void *
palacios_alloc(unsigned int size)
{
	return kalloc(size);
}

static void
palacios_free(void *ptr)
{
	return kfree(ptr);
}

static void *
palacios_vaddr_to_paddr(void *vaddr)
{
	return (void *)PADDR_DIRECT(vaddr);
}

static void *
palacios_paddr_to_vaddr(void *paddr)
{
	return (void *)KADDR_DIRECT(paddr);
}

static unsigned int
palacios_get_cpu_khz(void) 
{
	/* XXX */
	return 1000;
}

static void
palacios_yield_cpu(void)
{
	kthread_schedule();
}

static void 
palacios_start_kernel_thread(int (*fn)(void *arg),
							 void *arg,
							 char *thread_name)
{
    kthread_create(thread_name, fn, arg, KTHREAD_STACK_SIZE_DEFAULT);
}

static void 
palacios_xcall(int cpu_id, 
			   void (*fn)(void *arg),
			   void *arg)
{
	assert(cpu_id == 0);
	fn(arg);
}

static void 
palacios_start_thread_on_cpu(int cpu_id, 
							 int (*fn)(void * arg), 
							 void *arg, 
							 char *thread_name)
)
{
	kthread_create(thread_name, fn, arg, KTHREAD_STACK_SIZE_DEFAULT);
}

static unsigned int 
palacios_get_cpu(void) 
{
	return lcpu_idx;
}

static struct v3_os_hooks os_hooks =
{
	.print				 = palacios_print,
	.allocate_pages		 = palacios_allocate_pages,
	.free_page			 = palacios_free_page,
	.malloc				 = palacios_alloc,
	.free				 = palacios_free,
	.vaddr_to_paddr		 = palacios_vaddr_to_paddr,
	.paddr_to_vaddr		 = palacios_paddr_to_vaddr,
	.hook_interrupt		 = palacios_hook_interrupt,
	.ack_irq			 = palacios_ack_interrupt,
	.get_cpu_khz		 = palacios_get_cpu_khz,
	.start_kernel_thread = palacios_start_kernel_thread,
	.yield_cpu			 = palacios_yield_cpu,
	.mutex_alloc		 = palacios_mutex_alloc,
	.mutex_free			 = palacios_mutex_free,
	.mutex_lock			 = palacios_mutex_lock, 
	.mutex_unlock		 = palacios_mutex_unlock,
	.get_cpu			 = palacios_get_cpu,
	.interrupt_cpu		 = palacios_interrupt_cpu,
	.call_on_cpu		 = palacios_xcall,
	.start_thread_on_cpu = palacios_start_thread_on_cpu,
};

static struct guest_info *vm_info;

int
vm_init(void)
{
	Init_V3(&os_hooks, 1);

	extern char _binary_vm_image_start[];
	vm_info = v3_create_vm((void *)_binary_vm_image_start);

	if (!vm_info)
	{
		return -1;
	}

	return 0;
}

void
vm_start(void)
{
	v3_start_vm(vm_info, 0);
}
